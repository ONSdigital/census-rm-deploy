---
groups:
- name: "Overview"
  jobs:
  - "Trigger Deployment"
  - "Apply Database Patches"
  - "Action Scheduler"
  - "Action Worker"
  - "Case API"
  - "Case Processor"
  - "UAC QID Service"
  - "PubSub Service"
  - "Ops Tool"
  - "Print File Service"
  - "Fieldwork Adapter"
  - "Notify Processor"
  - "Exception Manager"
  - "Toolbox"
  - "Database Monitor"
  - "Rabbit Monitor"
  - "Regional Counts"
  - "Report Deployment Success"
  - "Trigger Terraform"
  - "Run Terraform"
  - "Run Rabbit Helm"
  - "Report Terraform Success"

- name: "Infrastructure"
  jobs:
  - "Trigger Terraform"
  - "Run Terraform"
  - "Run Rabbit Helm"
  - "Report Terraform Success"

- name: "App Deployment"
  jobs:
  - "Trigger Deployment"
  - "Apply Database Patches"
  - "Action Scheduler"
  - "Action Worker"
  - "Case API"
  - "Case Processor"
  - "UAC QID Service"
  - "PubSub Service"
  - "Ops Tool"
  - "Print File Service"
  - "Fieldwork Adapter"
  - "Notify Processor"
  - "Exception Manager"
  - "Toolbox"
  - "Database Monitor"
  - "Rabbit Monitor"
  - "Regional Counts"
  - "Report Deployment Success"

resource_types:
- name: slack-notification
  type: docker-image
  source:
    repository: cfcommunity/slack-notification-resource

resources:

- name: slack-alert
  type: slack-notification
  source:
    url: ((slack.webhook))

- name: census-rm-deploy
  type: git
  source:
    uri: git@github.com:ONSdigital/census-rm-deploy.git
    private_key: ((github.service_account_private_key))

- name: census-rm-terraform-release
  type: git
  source:
    uri: git@github.com:ONSdigital/census-rm-terraform.git
    private_key: ((github.service_account_private_key))
    tag_filter: v*.*.*
    branch: master

- name: census-rm-kubernetes-release
  type: git
  source:
    uri: git@github.com:ONSdigital/census-rm-kubernetes.git
    private_key: ((github.service_account_private_key))
    paths: [release/*]
    tag_filter: v*.*.*
    branch: master

- name: census-rm-ddl-release
  type: git
  source:
    uri: git@github.com:ONSdigital/census-rm-ddl.git
    private_key: ((github.service_account_private_key))
    tag_filter: v*.*.*
    branch: master

- name: every-minute
  type: time
  source:
    interval: 1m

templating:

slack_failure_alert: &slack_failure_alert
  put: slack-alert
  params:
    icon_emoji: ":concourse:"
    username: Concourse
    attachments: [
          {
              "fallback": "$BUILD_JOB_NAME failed. See build: $ATC_EXTERNAL_URL/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME",
              "title": "$BUILD_JOB_NAME failed",
              "title_link": "$ATC_EXTERNAL_URL/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME/jobs/$BUILD_JOB_NAME/builds/$BUILD_NAME",
              "fields": [
                  {
                      "title": "Pipeline",
                      "value": "$BUILD_PIPELINE_NAME",
                      "short": true
                  },
                  {
                      "title": "Environment",
                      "value": "((gcp-environment-name))",
                      "short": true
                  },
                  {
                      "title": "Project",
                      "value": "((gcp-project-name))",
                      "short": true
                  },
                  {
                      "title": "Build",
                      "value": "#$BUILD_NAME",
                      "short": true
                  }
              ],
              "color": "#F35A00"
          }
      ]

slack_success_alert: &slack_success_alert
  put: slack-alert
  params:
    icon_emoji: ":concourse:"
    username: Concourse
    attachments: [
          {
              "fallback": "((gcp-environment-name)) release succeeded. See build: $ATC_EXTERNAL_URL/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME",
              "title": "((gcp-environment-name)) Release Succeeded",
              "title_link": "$ATC_EXTERNAL_URL/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME",
              "fields": [
                  {
                      "title": "Pipeline",
                      "value": "$BUILD_PIPELINE_NAME",
                      "short": true
                  },
                  {
                      "title": "Environment",
                      "value": "((gcp-environment-name))",
                      "short": true
                  },
                  {
                      "title": "Project",
                      "value": "((gcp-project-name))",
                      "short": true
                  }
              ],
              "color": "#36a64f"
          }
      ]

slack_in_progress_alert: &slack_in_progress_alert
  put: slack-alert
  params:
    icon_emoji: ":concourse:"
    username: Concourse
    attachments: [
          {
              "fallback": "((gcp-environment-name)) release started. See build: $ATC_EXTERNAL_URL/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME",
              "title": "((gcp-environment-name)) Release Started",
              "title_link": "$ATC_EXTERNAL_URL/teams/$BUILD_TEAM_NAME/pipelines/$BUILD_PIPELINE_NAME",
              "fields": [
                  {
                      "title": "Pipeline",
                      "value": "$BUILD_PIPELINE_NAME",
                      "short": true
                  },
                  {
                      "title": "Environment",
                      "value": "((gcp-environment-name))",
                      "short": true
                  },
                  {
                      "title": "Project",
                      "value": "((gcp-project-name))",
                      "short": true
                  }
              ],
              "color": "#ffe100"
          }
      ]


jobs:

- name: "Trigger Deployment"
  serial: true
  plan:
    - get: every-minute
    - get: census-rm-kubernetes-release
  on_success: *slack_in_progress_alert

- name: "Apply Database Patches"
  disable_manual_trigger: true
  serial: true
  serial_groups: [apply-database-patches,
                  action-scheduler,
                  action-worker,
                  case-api,
                  case-processor,
                  uac-qid-service,
                  pubsubsvc,
                  ops,
                  print-file-service,
                  fieldwork-adapter,
                  notify-processor,
                  exception-manager,
                  toolbox,
                  database-monitor,
                  rabbitmonitor,
                  regionalcounts]
  plan:
  - get: every-minute
    trigger: true
  - get: census-rm-ddl-release
    trigger: true
    passed: ["Trigger Deployment"]
  - task: apply-database-patches
    config:
      platform: linux
      image_resource:
        type: docker-image
        source:
          repository: eu.gcr.io/census-gcr/gcloud-kubectl
      params:
        SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
        KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
        GCP_PROJECT_NAME: ((gcp-project-name))
        DDL-IMAGE: ((ddl-image))
      run:
        path: bash
        args:
          - -exc
          - |
            cat >~/gcloud-service-key.json <<EOL
            $SERVICE_ACCOUNT_JSON
            EOL

            # Use gcloud service account to configure kubectl
            gcloud auth activate-service-account --key-file ~/gcloud-service-key.json
            gcloud container clusters get-credentials ${KUBERNETES_CLUSTER} --zone europe-west2 --project ${GCP_PROJECT_NAME}

            # Create a pod and run the database patches from there
            # Env vars have to passed one by one as a --env flag each
            # The sleep is to give kubectl time to attach properly, otherwise the first few log lines are lost
            set +x
            kubectl run apply-database-patches -it --command --rm --quiet \
            --generator=run-pod/v1 \
            --image=${DDL_IMAGE} \
            --restart=Never \
            $(while read env; do echo --env=${env}; done \
            --env=DB_USERNAME=$(kubectl get secret db-credentials -o=jsonpath="{.data.username}" | base64 --decode) \
            --env=DB_PASSWORD=$(kubectl get secret db-credentials -o=jsonpath="{.data.password}" | base64 --decode) \
            --env=DB_HOST=$(kubectl get configmap db-config -o=jsonpath="{.data.db-host}") \
            --env=DB_PORT=$(kubectl get configmap db-config -o=jsonpath="{.data.db-port}") \
            --env=DB_NAME=$(kubectl get configmap db-config -o=jsonpath="{.data.db-name}") \
            --env=DB_USESSL= \     # TODO: Need to check this
            -- /bin/bash -c "sleep 2; PATCH_VERSION=$(cat census-rm-ddl-release/tag) ./patch_database_to_version.sh"
            set -x


- name: "Action Scheduler"
  disable_manual_trigger: true
  serial: true
  serial_groups: [action-scheduler]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-service-and-deploy
    file: census-rm-deploy/tasks/kubectl-apply-service-and-deploy-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: action-scheduler
      KUBERNETES_SELECTOR: app=action-scheduler
      KUBERNETES_FILE_PATH: kubernetes-repo/release/microservices
      KUBERNETES_FILE_PREFIX: action-scheduler
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Action Worker"
  disable_manual_trigger: true
  serial: true
  serial_groups: [action-worker]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-service-and-deploy
    file: census-rm-deploy/tasks/kubectl-apply-deployment-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: action-worker
      KUBERNETES_SELECTOR: app=action-worker
      KUBERNETES_FILE_PATH: kubernetes-repo/release/microservices
      KUBERNETES_FILE_PREFIX: action-worker
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Case API"
  disable_manual_trigger: true
  serial: true
  serial_groups: [case-api]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-service-and-deploy
    file: census-rm-deploy/tasks/kubectl-apply-service-and-deploy-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: case-api
      KUBERNETES_SELECTOR: app=case-api
      KUBERNETES_FILE_PATH: kubernetes-repo/release/microservices
      KUBERNETES_FILE_PREFIX: case-api
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Case Processor"
  disable_manual_trigger: true
  serial: true
  serial_groups: [case-processor]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-deployment
    file: census-rm-deploy/tasks/kubectl-apply-deployment-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: case-processor
      KUBERNETES_SELECTOR: app=case-processor
      KUBERNETES_FILE_PATH: kubernetes-repo/release/microservices
      KUBERNETES_FILE_PREFIX: case-processor
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "UAC QID Service"
  disable_manual_trigger: true
  serial: true
  serial_groups: [uac-qid-service]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-service-and-deploy
    file: census-rm-deploy/tasks/kubectl-apply-service-and-deploy-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: uacqidservice
      KUBERNETES_SELECTOR: app=uacqidservice
      KUBERNETES_FILE_PATH: kubernetes-repo/release/microservices
      KUBERNETES_FILE_PREFIX: uac-qid-service
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "PubSub Service"
  disable_manual_trigger: true
  serial: true
  serial_groups: [pubsubsvc]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-deployment
    file: census-rm-deploy/tasks/kubectl-apply-deployment-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: pubsubsvc
      KUBERNETES_SELECTOR: app=pubsubsvc
      KUBERNETES_FILE_PATH: kubernetes-repo/release/microservices
      KUBERNETES_FILE_PREFIX: pubsub
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Ops Tool"
  disable_manual_trigger: true
  serial: true
  serial_groups: [ops]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-deployment
    file: census-rm-deploy/tasks/kubectl-apply-service-and-deploy-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: ops
      KUBERNETES_SELECTOR: app=ops
      KUBERNETES_FILE_PATH: kubernetes-repo/release/optional
      KUBERNETES_FILE_PREFIX: ops
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Print File Service"
  disable_manual_trigger: true
  serial: true
  serial_groups: [print-file-service]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-deployment
    file: census-rm-deploy/tasks/kubectl-apply-statefulset-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_STATEFULSET_NAME: printfilesvc
      KUBERNETES_SELECTOR: app=printfilesvc
      KUBERNETES_FILE_PATH: kubernetes-repo/release/microservices
      KUBERNETES_FILE_PREFIX: print-file-service
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Fieldwork Adapter"
  disable_manual_trigger: true
  serial: true
  serial_groups: [fieldwork-adapter]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-deployment
    file: census-rm-deploy/tasks/kubectl-apply-deployment-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: fieldwork-adapter
      KUBERNETES_SELECTOR: app=fieldwork-adapter
      KUBERNETES_FILE_PATH: kubernetes-repo/release/microservices
      KUBERNETES_FILE_PREFIX: fieldwork-adapter
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Notify Processor"
  disable_manual_trigger: true
  serial: true
  serial_groups: [notify-processor]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-deployment
    file: census-rm-deploy/tasks/kubectl-apply-deployment-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: notify-processor
      KUBERNETES_SELECTOR: app=notify-processor
      KUBERNETES_FILE_PATH: kubernetes-repo/release/microservices
      KUBERNETES_FILE_PREFIX: notify-processor
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Exception Manager"
  disable_manual_trigger: true
  serial: true
  serial_groups: [exception-manager]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-service-and-deploy
    file: census-rm-deploy/tasks/kubectl-apply-service-and-deploy-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: exception-manager
      KUBERNETES_SELECTOR: app=exception-manager
      KUBERNETES_FILE_PATH: kubernetes-repo/release/microservices
      KUBERNETES_FILE_PREFIX: exception-manager
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Toolbox"
  disable_manual_trigger: true
  serial: true
  serial_groups: [toolbox]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-deployment
    file: census-rm-deploy/tasks/kubectl-apply-deployment-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: census-rm-toolbox
      KUBERNETES_SELECTOR: app=census-rm-toolbox
      KUBERNETES_FILE_PATH: kubernetes-repo/release/optional
      KUBERNETES_FILE_PREFIX: census-rm-toolbox
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Database Monitor"
  disable_manual_trigger: true
  serial: true
  serial_groups: [database-monitor]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-deployment
    file: census-rm-deploy/tasks/kubectl-apply-deployment-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: database-monitor
      KUBERNETES_SELECTOR: app=database-monitor
      KUBERNETES_FILE_PATH: kubernetes-repo/release/optional
      KUBERNETES_FILE_PREFIX: database-monitor
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Rabbit Monitor"
  disable_manual_trigger: true
  serial: true
  serial_groups: [rabbitmonitor]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-deployment
    file: census-rm-deploy/tasks/kubectl-apply-deployment-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: rabbitmonitor
      KUBERNETES_SELECTOR: app=rabbitmonitor
      KUBERNETES_FILE_PATH: kubernetes-repo/release/optional
      KUBERNETES_FILE_PREFIX: rabbitmonitor
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Regional Counts"
  disable_manual_trigger: true
  serial: true
  serial_groups: [regionalcounts]
  plan:
  - get: census-rm-kubernetes-release
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - get: census-rm-deploy
  - get: every-minute
    trigger: true
    passed: ["Trigger Deployment", "Apply database patches"]
  - task: apply-deployment
    file: census-rm-deploy/tasks/kubectl-apply-deployment-no-patch.yml
    on_failure: *slack_failure_alert
    params:
      SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
      GCP_PROJECT_NAME: ((gcp-project-name))
      KUBERNETES_CLUSTER: ((kubernetes-cluster-name))
      KUBERNETES_DEPLOYMENT_NAME: regionalcounts
      KUBERNETES_SELECTOR: app=regionalcounts
      KUBERNETES_FILE_PATH: kubernetes-repo/release/optional
      KUBERNETES_FILE_PREFIX: regional-counts
      WAIT_UNTIL_AVAILABLE_TIMEOUT: 200s
    input_mapping: {kubernetes-repo: census-rm-kubernetes-release}

- name: "Report Deployment Success"
  disable_manual_trigger: true
  serial: true
  plan:
  - get: every-minute
    trigger: true
    passed: ["Apply database patches",
            "Action Scheduler",
            "Case API",
            "Case Processor",
            "UAC QID Service",
            "PubSub Service",
            "Print File Service",
            "Ops Tool",
            "Fieldwork Adapter",
            "Notify Processor",
            "Exception Manager",
            "Toolbox",
            "Database Monitor",
            "Rabbit Monitor",
            "Regional Counts"]
  - *slack_success_alert

# Infrastructure
- name: "Trigger Terraform"
  serial: true
  serial_groups: [
    action-scheduler,
    action-worker,
    case-api,
    case-processor,
    fieldwork-adapter,
    notify-processor,
    uac-qid-service,
    pubsubsvc,
    print-file-service,
    exception-manager,
    toolbox,
    event-latency-monitor,
    rabbitmonitor]
  on_failure: *slack_failure_alert
  plan:
    - get: every-minute

- name: "Run Terraform"
  disable_manual_trigger: true
  serial: true
  serial_groups: [action-scheduler,
                  action-worker,
                  case-api,
                  case-processor,
                  fieldwork-adapter,
                  notify-processor,
                  uac-qid-service,
                  pubsubsvc,
                  print-file-service,
                  exception-manager,
                  toolbox,
                  event-latency-monitor,
                  rabbitmonitor]
  on_failure: *slack_failure_alert
  plan:
    - get: every-minute
      trigger: true
      passed: ["Trigger Terraform"]
    - get: census-rm-terraform-release
    - get: census-rm-deploy
    - task: "Run Terraform"
      file: census-rm-deploy/tasks/terraform-env.yml
      params:
        ADMIN_SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
        ENV: ((gcp-environment-name))
        VAR_FILE: ./tfvars/census-rm-blacklodge.tfvars
        KUBERNETES_CLUSTER: rm-k8s-cluster
      input_mapping: {census-rm-terraform: census-rm-terraform-release}

- name: "Run Rabbit Helm"
  disable_manual_trigger: true
  serial: true
  serial_groups: [action-scheduler,
                  action-worker,
                  case-api,
                  case-processor,
                  fieldwork-adapter,
                  notify-processor,
                  uac-qid-service,
                  pubsubsvc,
                  print-file-service,
                  exception-manager,
                  toolbox,
                  event-latency-monitor,
                  rabbitmonitor]
  on_failure: *slack_failure_alert
  plan:
    - get: every-minute
      trigger: true
      passed: ["Run Terraform"]
    - get: census-rm-kubernetes-release
    - get: census-rm-deploy
    - task: "Run Rabbit Helm"
      file: census-rm-deploy/tasks/helm-rabbit.yml
      params:
        ADMIN_SERVICE_ACCOUNT_JSON: ((gcp.service_account_json))
        ENV: ((gcp-environment-name))
        KUBERNETES_CLUSTER: rm-k8s-cluster
        RABBITMQ_CONFIG_VALUES_FILE: release/rabbitmq/values.yml
      input_mapping: {census-rm-kubernetes-dependencies-repo: census-rm-kubernetes-release}

- name: "Report Terraform Success"
  disable_manual_trigger: true
  serial: true
  plan:
  - get: every-minute
    trigger: true
    passed: [
      "Run Terraform",
      "Run Rabbit Helm"]
  - *slack_success_alert